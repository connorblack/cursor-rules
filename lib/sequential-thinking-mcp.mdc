---
description: Sequential thinking tool for complex, multi-step reasoning and problem decomposition
alwaysApply: true
---
## When to Use Sequential Thinking

Automatically activate `sequential_thinking` when you detect these specific patterns:

### Problem Complexity Indicators (Use Immediately)

- **Multi-component systems**: "Build a full-stack application with authentication, database, and API"
- **Algorithmic challenges**: "Implement a distributed consensus algorithm"
- **Architecture decisions**: "Design a scalable microservices architecture for [use case]"
- **Debugging complex issues**: Multiple interacting bugs or system-wide problems
- **Performance optimization**: Multi-layered optimization requiring trade-off analysis

### During Problem Solving (Activate When You Notice)

- You need to track multiple constraints or requirements
- The solution requires validating assumptions before proceeding
- You're unsure of the full scope until you explore the problem
- Previous attempts or approaches might need revision
- Multiple valid solutions exist and need comparison

## Usage Pattern

Start sequential thinking when you recognize you need to:

1. **Decompose** - Break the problem into logical sub-problems
2. **Explore** - Investigate each component while maintaining context
3. **Revise** - Adjust your approach based on discoveries
4. **Branch** - Consider alternative solutions when stuck
5. **Verify** - Test your hypothesis before presenting the solution

## Concrete Trigger Examples

User asks: "Create a rate limiter with multiple strategies"
→ Use sequential thinking to: Define requirements → Design data structures → Implement strategies → Handle edge cases → Verify correctness

User asks: "Debug why my distributed system is failing intermittently"
→ Use sequential thinking to: Identify symptoms → Form hypotheses → Test each hypothesis → Revise based on findings → Isolate root cause

User asks: "Optimize this algorithm that's running slowly"
→ Use sequential thinking to: Profile current implementation → Identify bottlenecks → Consider optimization strategies → Evaluate trade-offs → Implement best approach

## Tool Parameters Guide

- **thought**: Current reasoning step (be specific and concrete)
- **nextThoughtNeeded**: Continue if problem isn't fully solved
- **thoughtNumber/totalThoughts**: Adjust totalThoughts as scope becomes clearer
- **isRevision**: Use when new information contradicts earlier thinking
- **branchFromThought**: Use when exploring alternative approaches
- **needsMoreThoughts**: Signal when initial estimate was insufficient

## Integration Rule

Sequential thinking enhances your problem-solving by:

- Maintaining context across complex reasoning chains
- Allowing mid-process course correction
- Documenting your reasoning for transparency
- Preventing overlooked edge cases or requirements

Remember: Complex problems deserve structured thinking. Users value thorough, well-reasoned solutions over quick but potentially flawed answers.
