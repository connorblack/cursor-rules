---
name: universal-mcp-loop
description: Continuous tool utilization with memory persistence
alwaysApply: true
---

# The Four Pillars (Use Throughout EVERY Interaction)

## 1️⃣ SEQUENTIAL THINKING - Your Cognitive Framework

ALWAYS active for:

- Any code generation beyond 10 lines
- Multi-file modifications
- Debugging sessions
- Architecture decisions
- Complex explanations

Pattern: Think → Act → Reflect → Store

## 2️⃣ EXA SEARCH - Your Current Knowledge

Proactive triggers (don't wait to be asked):

- Before EVERY import statement → verify current syntax
- Before EVERY function implementation → check best practices
- On EVERY error → search exact message
- On EVERY library reference → get latest patterns
- Every 50 lines of code → verify approach is current

## 3️⃣ CONTEXT7 - Your Documentation Layer  

Automatic activation:

- Scan code for imports → resolve ALL libraries immediately
- Pre-fetch docs for detected frameworks
- Cache documentation context for entire session
- Refresh if version changes detected

## 4️⃣ NEO4J MEMORY - Your Persistent Brain

Continuous memory loop:

**PRE-STEP (Retrieve):**
→ search_memories(current_context)
→ Load relevant project patterns
→ Retrieve previous decisions

**DURING-STEP (Connect):**
→ Track new entities discovered
→ Link related concepts
→ Note decision points

**POST-STEP (Persist):** [MANDATORY]
→ create_entities([new_concepts])
→ add_observations(implementation_details)
→ create_relations(concept_connections)
→ Store error-solution pairs
→ Record performance insights

# Execution Flow for EVERY Request

START
↓
[MEMORY RETRIEVE] - What do I know about this?
↓
[SEQUENTIAL THINKING] - How will I approach this?
↓
[SEARCH + CONTEXT7] - What's the current best practice?
↓
[IMPLEMENTATION] - Execute with context
↓
[MEMORY PERSIST] - What did I learn?
↓
END

# Parallel Execution Strategy

Run simultaneously:

- neo4j.search_memories()
- context7.resolve-library-id() for all detected libraries
- exa.web_search() for immediate questions
- sequential_thinking.start()

Then converge results for implementation.

# Memory Persistence Patterns

## After EVERY Code Block

entities: [functions, classes, patterns used]
relations: [IMPLEMENTS, USES, DEPENDS_ON]
observations: [performance notes, complexity, purpose]

## After EVERY Error Resolution

entities: [error_type, solution]
relations: [ERROR_SOLVED_BY]
observations: [root cause, prevention]

## After EVERY Architecture Decision

entities: [pattern, alternative_patterns]
relations: [CHOSEN_OVER, BECAUSE]
observations: [trade-offs, context, rationale]
